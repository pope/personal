# -*- fill-column: 78; -*-
#+title: My Emacs Config
#+author: K. Adam Christensen
#+language: en
#+property: header-args :emacs-lisp :tangle ./init.el :mkdirp yes

* Goal

To configure emacs while also commenting and documenting the process for the setup.

* Methodology

My idea for this config is one part Nix, one part Emacs with [[elisp:(describe-function 'use-package)][use-package]]. Nix will supply all of the dependency emacs packages, and =use-pacakge= will be used to configure things.

While Emacs can run in server-mode, I still want the editor to load as quickly as possible. So I will try to lazy load as much as possible when I can - even to the point it may be aggressive.

In order to use changes in this file, use =M-x org-babel-tangle= to export the elisp in here to the =init.el= file.

* Enable lexical binding

Not sure what this does for performance or how the init functions, but adding it because.

#+begin_src emacs-lisp
  ;;; -*- lexical-binding: t -*-
#+end_src

* Tuning for speed

The Emacs garbage collector runs many times during app start. So at the start, we increase the amount of GC temporarily at the start. At the end of this doc, we can reset it (though not quite as low). The default is 800kb.

References:
- https://emacsconf.org/2023/talks/gc/
- https://github.com/protesilaos/dotfiles/blob/master/emacs/.emacs.d/prot-emacs.org

#+begin_src emacs-lisp
  ;; Measured in bytes.
  (setq gc-cons-threshold most-positive-fixnum
        gc-cons-percentage 0.5)
  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq gc-cons-threshold (* 8 1000 1000)
                    gc-cons-percentage 0.1)))
#+end_src

* Running as a server

If ever we run Emacs in daemon/server mode, a lot of the lazy loading and deferred loading which can kinda counteract the benefit of running an Emacs server. So if running as a daemon, we can force all =use-package= calls to immediately load.

#+begin_src emacs-lisp
  (use-package use-package
    :if (daemonp)
    :custom (use-package-always-demand t))
#+end_src

* Core Settings

** Color Theme

Using [[https://github.com/doomemacs/themes][doom-themes]]. It's a nice set of themes, though it doesn't contain Catppuccin or Rose-Pine. This is in the core settings and not UI primarily because we want this to happen as early as possible. If not, we can get a flash of white as Emacs loads.

#+begin_src emacs-lisp
  (use-package doom-themes
    :custom
    (doom-themes-enable-bold t)
    (doom-themes-enable-italic t)
    :config
    (load-theme 'doom-nord t)
    ;; Corrects (and improves) org-mode's native fontification.
    (doom-themes-org-config))
#+end_src

** Transparency

I like a little transparency, but sometimes it can be a tad jank. The function =pope-set-background-alpha= is there to interactively set the transparency to any value I want. And I can always customize the variable per device if ever I so should choose.

#+begin_src emacs-lisp
  (defun pope-set-background-alpha (val)
    (interactive "nAlpha: ")
    (set-frame-parameter nil 'alpha-background val)
    (add-to-list 'default-frame-alist `(alpha-background . ,val)))
#+end_src

:NOTE:
This does make the =menu-bar= on my Linux machine with a GTK show as fully transparent background. And this mode doesn't work for transparency in TTY mode.
:END:

** Custom file

I don't want quick Emacs customizations to show up in the init file. So we can add it to it's own file.

#+begin_src emacs-lisp
  (setq custom-file "~/.emacs.d/custom.el")
  (load custom-file t)
#+end_src

** Config

First, let's put extra emacs files into the =.emacs.d= directory, namely auto-saves and backups. Then we can enable puting auto-saves into that path and enable =save-place-mode= which will keep it's history in the =.emacs.d= location.

:NOTE:
The Nix configuration should make sure that the auto-saves and backup directories exist. Otherwise the backup and saves can fail.
:END:

#+begin_src emacs-lisp
  (use-package emacs
    :custom
    (recentf-mode t)
    (save-place-mode t)
    :init
    (setq auto-save-file-name-transforms `((".*" "~/.emacs.d/auto-saves/" t))
          backup-directory-alist         `(("." . "~/.emacs.d/backups/")))
    :hook
    (after-init . which-key-mode))
#+end_src

* Editing

** Basics

The first thing we can set up for the editing experience is to leverage project EditorConfig settings. This is something that's available with Emacs 30, and can be set with a custom variable. Additionally, it would be nice to auto-revery buffers when things change on disk.

#+begin_src emacs-lisp
  (use-package emacs
    :custom
    (fill-column 78)
    (editorconfig-mode t)
    (global-auto-revert-non-file-buffers t)
    (global-auto-revert-mode t))
#+end_src

Next, we can use =expand-region= so that we can select things in strings, or parenthesis, etc.

#+begin_src emacs-lisp
  (use-package expand-region
    :bind ("M-SPC" . er/expand-region))
#+end_src

Finally, =multiple-cursors= allows for quick selection and edit at once

#+begin_src emacs-lisp
  (use-package multiple-cursors
    :bind
    ("C-S-c C-S-c"  . mc/edit-lines)
    ("C->"          . mc/mark-next-like-this)
    ("C-<"          . mc/mark-previous-like-this)
    ("C-c C-<"      . mc/mark-all-like-this))
#+end_src

** Clipboard

When on [[https://wayland.freedesktop.org/][Wayland]] I was noticing that copy/paste was not working. Using [[https://elpa.gnu.org/packages/xclip.html][xclip]] seems to address that.

#+begin_src emacs-lisp
  (use-package xclip
    :custom (xclip-mode t))
#+end_src

=clipetty= is needed so that copy/paste works in terminals as well.

#+begin_src emacs-lisp
  (use-package clipetty
    :custom (global-clipetty-mode t))
#+end_src

** Vim style

[[https://github.com/emacs-evil/evil][Evil mode]] exists to emulate vim modes and shortcuts. I will keep it around, but not exactly load it and use it immediately. But run =M-x evil-mode= to turn it on.

#+begin_src emacs-lisp
  (use-package evil
    :commands (evil-mode))
#+end_src

* Completions

Adding some modern completion code for Emacs

Sources:
- https://protesilaos.com/codelog/2024-02-17-emacs-modern-minibuffer-packages/
- https://www.youtube.com/watch?v=SOxlQ7ogplA

** Minibuffer

*** Minibuffer...again?

The minibuffer package, which is built into Emacs, allows for all sort of completion commands, from code completions to searching through variables, functions, and files.

#+begin_src emacs-lisp
  (use-package minibuffer
    :custom
    (completion-auto-help 'visible)
    (completion-auto-select t) ;; Show completion on first call
    (completion-show-help nil) ;; Skip docs for M-<down>, M-<up>, M-<RET>
    (completion-show-inline-help t)
    (completions-detailed t)
    (completions-max-height 20)
    (completions-sort 'historical)
    ;; Yo dawg, I heard you like minibuffers.
    (enable-recursive-minibuffers t))
#+end_src

*** Vertico

[[https://github.com/minad/vertico][Vertico]] positions completions in a vertical column in the minibuffer.

#+begin_src emacs-lisp
  (use-package vertico
    :custom
    (vertico-cycle t)
    (vertico-resize nil)
    (vertico-mode t)
    :hook
    (rfn-eshadow-update-overlay-hook . vertico-directory-tidy))
#+end_src

The vertico docs also recommend the following configs

#+begin_src emacs-lisp
  ;; Enable saving of minibuffer history
  (use-package savehist
    :custom (history-delete-duplicates t)
    :hook (after-init . savehist-mode))

  (use-package simple
    :custom
    ;; Hide commands in M-x that are incompatible for the current mode.
    (read-extended-command-predicate #'command-completion-default-include-p))

  (use-package crm
    :if (< emacs-major-version 31)
    :init
    ;; Add prompt indicator to `completing-read-multiple'.
    ;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
    (advice-add #'completing-read-multiple :filter-args
                (lambda (args)
                  (cons (format "[CRM%s] %s"
                                (string-replace "[ \t]*" "" crm-separator)
                                (car args))
                        (cdr args)))))

  ;; Do not allow the cursor in the minibuffer prompt
  (use-package emacs
    :custom
    (minibuffer-prompt-properties
     '(read-only-mode t cursor-intangible-mode t face minibuffer-prompt))
    :hook
    (minibuffer-setup-hook . cursor-intangible-mode))
#+end_src

*** Marginalia

[[https://github.com/minad/marginalia][Marginalia]] adds extra context in the minibuffer for whatever is being completed.

#+begin_src emacs-lisp
  (use-package marginalia
    :demand t
    :bind (:map minibuffer-local-map
                ("M-A" . marginalia-cycle))
    :custom (marginalia-mode t))
#+end_src

*** Orderless

[[https://github.com/oantolin/orderless][Orderless]] is a package that divides completion patterns by spaces to match the components in order.

#+begin_src emacs-lisp
  (use-package orderless
    :custom
    ;; These are minibuffer custom variables, but tailored for orderless
    (completion-styles '(orderless basic))
    (completion-category-overrides
     '((file (styles basic partial-completion)))))
#+end_src

*** Consult

[[https://github.com/minad/consult][Consult]] provides search and navigation with completion functions. The consult documentation includes a lot more options than I'm using now - so I will revisit to see if I want to add more.

#+begin_src emacs-lisp
  (use-package consult
    :bind (:map global-map
                ("M-s M-r" . consult-recent-file)
                ("M-s M-g" . consult-ripgrep)
                ("M-s M-f" . consult-fd)
                ("M-s M-o" . consult-outline)
                ("M-s M-i" . consult-imenu)
                ("M-s M-l" . consult-line)
                ("M-s M-b" . consult-buffer)))
#+end_src

*** Embark

[[https://github.com/oantolin/embark][Embark]] provides mini-buffer actions for a target point.

#+begin_src emacs-lisp
  (use-package embark
    :bind (("C-."    . embark-act)       ;; pick some comfortable binding
           ("C-;"    . embark-dwim)      ;; good alternative: M-.
           ("C-h B"  . embark-bindings)) ;; alternative for `describe-bindings'
    :init
    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)
    :config
    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none)))))
#+end_src

Then we can join embark and consult together

#+begin_src emacs-lisp
  (use-package embark-consult
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

** In-Buffer

*** Corfu

[[https://github.com/minad/corfu][Corfu]] does in-buffer completions with a pop-up.

#+begin_src emacs-lisp
  (use-package corfu
    :custom
    (corfu-cycle t)
    ;; Fixes a bug for me where the first item is wonky
    (corfu-preselect 'prompt)
    :init
    (global-corfu-mode t)
    (corfu-history-mode)
    (corfu-popupinfo-mode))
#+end_src

In the regular Emacs config, we can make the =<TAB>= key trigger an autocomplete.

#+begin_src emacs-lisp
  (use-package emacs
    :custom
    (tab-always-indent 'complete)
    (text-mode-ispell-word-completion nil)
    (read-extended-command-predicate #'command-completion-default-include-p))
#+end_src

The settings above work fine in GUI mode, but for terminal, we need a separate package for that.

#+begin_src emacs-lisp
  (use-package corfu-terminal
    :if (not (display-graphic-p))
    :after corfu
    :custom (corfu-terminal-mode t))
#+end_src

=corfu= can also use =orderless=, and since it's configured above, there isn't anything to worry about here.

*** Cape

[[https://github.com/minad/cape][cape]] provides additional =capf= backends. This is something to consider adding to my configuration.

* The UI

This is all of the UI tweaks - outside of themeing. The theme config happens early in the startup to avoid flashes of white if the theme were to load later in the init process.

** Basic Config

Some basic emacs stuff to add/remove UI to emacs.

#+begin_src emacs-lisp
  (use-package emacs
    :custom
    (display-line-numbers-grow-only t)
    (display-line-numbers-type 'relative)
    (display-line-numbers-width 3)
    (inhibit-startup-screen t)     ; Don't show startup message
    (confirm-kill-emacs 'y-or-n-p) ; Less typing when quitting
    (column-number-mode t)
    (global-display-line-numbers-mode +1)
    (global-hl-line-mode t)
    (global-visual-line-mode t)
    (menu-bar-mode nil)
    (tool-bar-mode nil)
    (winner-mode t))
#+end_src

** Diffs

=diff-hl= provides a way to see changes to the file in the gutter/fringe of the file, and not just Git. It does require =vc-handled-backends= to be set - which is by default for my Emacs installation. Through the use of the margin-mode variant, the diff changes can be highlighted from the terminal as well.

#+begin_src emacs-lisp
  (use-package diff-hl
    :custom
    (diff-hl-update-async t)
    (diff-hl-margin-mode t)
    :hook
    (after-init . global-diff-hl-mode)
    (magit-pre-refresh . diff-hl-magit-pre-refresh)
    (magit-post-refresh . diff-hl-magit-post-refresh))
#+end_src

** Nerd Icons

This package is nice if I want to enter in some =nerd-icons-insert=. It also has the benefit of adding Symbols for Nerd Font as a font for the regions where the font is applicable.

#+begin_src emacs-lisp
  (use-package nerd-icons
    :if (display-graphic-p)
    :defer t
    :config (nerd-icons-set-font))
#+end_src

There are some packages that make nerd fonts work with other packages or core emacs components.

#+begin_src emacs-lisp
  (use-package nerd-icons-dired
    :after (dired nerd-icons)
    :hook (dired-mode . nerd-icons-dired-mode))

  (use-package nerd-icons-ibuffer
    :after (ibuffer nerd-icons)
    :hook (ibuffer-mode . nerd-icons-ibuffer-mode))

  (use-package nerd-icons-corfu
    :after (corfu nerd-icons)
    :config (add-to-list 'corfu-margin-formatters
                         #'nerd-icons-corfu-formatter))

  (use-package nerd-icons-completion
    :demand t  ;; nerd-icons-completion-mode needs to run before hooks
    :after (marginalia nerd-icons)
    :hook (marginalia-mode-hook . nerd-icons-completion-marginalia-setup)
    :config (nerd-icons-completion-mode))
#+end_src

** Ligatures

I like ligatures. So this sets those up for all programming modes.

#+begin_src emacs-lisp
  (use-package ligature
    :config
    ;; Enable all ligatures in programming modes
    (ligature-set-ligatures
     'prog-mode
     '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
       ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
       "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
       "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
       "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
       "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
       "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
       "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
       ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
       "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
       "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
       "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
       "\\\\" "://"))
    (global-ligature-mode t))
#+end_src

** Scrolling

We could rely on the scrollbars provided by Emacs, but for whatever reason, I want to have more fun - and =nyan-mode= does that. It doesn't auto activate, but it's there! Also, scrolling is a little stiff by default, so we can enable pixel-level scrolling for a bit of smoothness.

#+begin_src emacs-lisp
  (use-package emacs
    :custom
    (fast-but-imprecise-scrolling t))

  (use-package ultra-scroll
    :custom
    (scroll-conservatively 3)
    (scroll-margin 0) ;; Required for smooth scrolling
    (scroll-bar-mode nil)
    :config
    (ultra-scroll-mode 1))
#+end_src

Scrolling can also be wonky when using a mouse in TTY mode. So we can enable =xterm-mouse-mode= to make that - and other things like menu selection - work.

#+begin_src emacs-lisp
  (use-package emacs
    :if (not (display-graphic-p))
    :config (xterm-mouse-mode 1))
#+end_src

** Indentation

I like seeing a line for where the indentation levels.

#+begin_src emacs-lisp
  (use-package indent-bars
    :commands (indent-bars-mode)
    :custom
    (indent-bars-color '(highlight :face-bg t :blend 0.2))
    (indent-bars-highlight-current-depth '(:blend 0.5))
    (indent-bars-pad-frac 0.1)
    (indent-bars-pattern ".")
    (indent-bars-starting-column 0)
    (indent-bars-treesit-support t)
    (indent-bars-width-frac 0.1)
    (indent-bars-zigzag nil)
    :config (require 'indent-bars-ts))
#+end_src

** Modeline

Using =doom-modeline= to have a fancier looking modeline bar at the bottom of the editor. The minor modes are hidden, as it takes up extra room in the modeline, and it's often incomplete. =M-x describe-mode= (=C-h m=) is a good way to get the full info about what is enabled anyway.

:NOTE:
=S-TAB= is a good way to toggle the headings in the mode *Help* buffer to get a quick overview of things.
:END:

#+begin_src emacs-lisp
  (use-package doom-modeline
    :custom
    (doom-modeline-buffer-encoding 'nondefault)
    (doom-modeline-minor-modes t)
    :hook
    (after-init . doom-modeline-mode)
    (after-init . minions-mode))
#+end_src

** Directory / file navigation

=dired= is a mode that allows for navigation of directories along with file manipulation. Configured above, icons have been enabled, but there are a few extra tweaks we can do.

The variable =dired-dwim-target= means that Dired will try to guess what I might want to do. So I can mark a file in one directory, navigate to a new one, and when I try to rename the file, it will assume I want to move the marked files into that directory.

On the UI side, I use =dired-hide-details-mode= so that I'm just looking at the file names, and not all of the other data like permissions and owners.

#+begin_src emacs-lisp
  (use-package dired
    :custom
    (dired-dwim-target t)
    :hook
    (dired-mode-hook . dired-hide-details-mode))
#+end_src

[[https://protesilaos.com/codelog/2023-06-26-emacs-file-dired-basics/][Emacs: file and Dired basics]] has a nice video and other options.

* Programming

Lastly, let's add support for programming languages. =nix-mode= (and one with treesit) and =zig-mode= (and also with treesit) are installed through Nix and have auto-loads configured. So there isn't anything that we need to do here. The goal with installing =-mode= and =-ts-mode= packages is to use ts version as the main major mode, but still use features from the normal mode.

Speaking of treesit and treesitter, I do want Emacs to use the =-ts-mode= versions of major modes. With Emacs 29, there's a remap list where we can say instead of loading one mode, load the next. Learn more on the [[https://www.masteringemacs.org/article/how-to-get-started-tree-sitter][How to get started with tree-sitter article]] on /Mastering Emacs/ site.

#+begin_src emacs-lisp
  (setq major-mode-remap-alist
        '(
          (bash-mode        . bash-ts-mode)
          (c-mode           . c-ts-mode)
          (c++-mode         . c++-ts-mode)
          (c-or-c++-mode    . c-or-c++-ts-mode)
          (css-mode         . css-ts-mode)
          (js-mode          . js-ts-mode)
          (js2-mode         . js-ts-mode)
          (java-mode        . java-ts-mode)
          (json-mode        . json-ts-mode)
          (ruby-mode        . ruby-ts-mode)
          (nix-mode         . nix-ts-mode)
          (protobuf-mode    . protobuf-ts-mode)
          (python-mode      . python-ts-mode)
          (typescript-mode  . typescript-ts-mode)
          (yaml-mode        . yaml-ts-mode)
          (zig-mode         . zig-ts-mode)))
#+end_src

:NOTE:
Using =treesit-auto= is a common tool for doing the mapping above, but it also has code to download TreeSit parsers if they are not available. Nix already has those parsers - so I control adding through that. Thus, =treesit-auto= does more than I need and I can just keep it simple here.
:END:

Next up, there are some treesit modes that are available, but they do not autoload when visiting a buffer. So we shall address that next.

#+begin_src emacs-lisp
  (use-package cmake-ts-mode
    :mode ("CMakeLists\\.txt\\'" "\\.cmake\\'"))
  (use-package go-ts-mode
    :mode "\\.go\\'")
  (use-package rust-ts-mode
    :mode "\\.rs\\'")
#+end_src

** LSP support with Eglot

For better code complete and code searching, we can use an LSP. =Eglot= gives us that library for doing the integration, and most things work right out of the box - especially for the =-mode= languages. But because I'm doing with the =-ts-mode= versions, there is some tweaking I need to do to properly map the ts-mode version to an LSP.

#+begin_src emacs-lisp
  (with-eval-after-load 'eglot
    (dolist (el '((nix-ts-mode . ("nixd"))
                  (zig-ts-mode . ("zls"))))
      (add-to-list 'eglot-server-programs el)))
#+end_src

And we can auto-start =eglot= when some modes activate

#+begin_src emacs-lisp
  (use-package eglot
    :hook ((c-ts-mode     . eglot-ensure)
           (c++-ts-mode   . eglot-ensure)
           (go-ts-mode    . eglot-ensure)
           (nix-ts-mode   . eglot-ensure)
           (rust-ts-mode  . eglot-ensure)
           (zig-ts-mode   . eglot-ensure)))
#+end_src

Lastly, let's format the buffer before we save to keep things nice and tidy.

#+begin_src emacs-lisp

  (with-eval-after-load 'eglot
    (defun pope--eglot-ensure-formatting ()
      (if (eglot-managed-p)
          (add-hook 'before-save-hook #'eglot-format-buffer nil t)
        (remove-hook 'before-save-hook #'eglot-format-buffer t)))

    (add-hook 'eglot-managed-mode-hook #'pope--eglot-ensure-formatting))

#+end_src

** Direnv support

I don't only use Nix for my config files - I also use it for all of my projects. Many/most of those projects use =direnv= to create a local environment where the tools needed to build the project are made available - including LSP servers. So to make things easy, we can have Emacs bring in those configurations automatically.

#+begin_src emacs-lisp
  (use-package direnv
    :custom (direnv-mode t))
#+end_src

** Ansi Colors in Compilation

Using the =compile= (or better yet, =project-compile=) command is really handy for running and re-running compilation of code or just a one-off command. But one thing that can suck is that ansi colors from some commands show up as escape characters in that buffer. Well, =ansi-colors= to the rescue

#+begin_src emacs-lisp
  (use-package ansi-color
    :hook (compilation-filter . ansi-color-compilation-filter))
#+end_src

** A Terminal

I have a complex terminal setup - it's where I tend to do most of my work, and so I use fancy (overlay complicated) TUIs and icons and settings - all of which can make =vterm= have problems displaying everything unless we tweak a few things. Some of the properties above like showing line numbers or a visual line don't make sense for a vterm session - so those get disable. The odd one though is =toggle-truncate-lines=. The Oh-My-Posh prompt can cause the line (which should be on just one line) break to another line. Then there are TUI apps like =lazygit= which can also exibit this longer-than-one-line issue. Truncating - while not perfect, does a better job of making things readible and usable.

#+begin_src emacs-lisp
  (use-package vterm
    :commands (vterm)
    :hook
    (vterm-mode-hook . (lambda ()
                         (display-line-numbers-mode -1)
                         (visual-line-mode -1)
                         (toggle-truncate-lines 1))))
#+end_src

* Documents

For documents, I want them to look like text documents and not fixed-width blocks of code (that is, unless we are showing off code). To that end, Org and Markdown docs will get a little special formatting with =variable-pitch-mode=.

There is some setup that can apply to both. So the first thing to do, set the default variable fonts. This is part of the =:custom-face= part of =use-package= so that they can still be customized per device.

I did try to set =fixed-pitch= to inherit from =default=, but that didn't seem to work. So if customizing one, customize the other to match.

#+begin_src emacs-lisp
  (use-package emacs
    :custom-face
    (default (nil (:font "Monospace")))
    (fixed-pitch (nil (:font "Monospace")))
    (variable-pitch (nil (:family "Sans Serif") (:height 1.2))))
#+end_src

** Prework: Font Faces

For any =set-face-attribute= calls that we add below, we are going to capture those in a new function. This is because there are times when I try loading a theme that the theme overwrites what I have. By keeping them in a function we recall those settings.

#+begin_src emacs-lisp :noweb yes
  (defun pope-set-document-faces (&optional theme)
    (interactive)
    ;; Ensure line numbers have fixed pitchs so that left alignment
    ;; isn't wonky
    (set-face-attribute 'line-number nil :inherit 'fixed-pitch :height 0.9)
    (set-face-attribute 'line-number-current-line nil
                        :inherit 'fixed-pitch :height 0.9)

    ;; org-mode faces. If one face exists, set them all
    (when (facep 'org-default)
      <<org-headings>>
      <<org-fixed-pitch-faces>>)

    ;; markdown-mode faces
    (when (facep 'markdown-header-face)
      <<markdown-faces>>))

  (add-hook 'enable-theme-functions #'pope-set-document-faces)
#+end_src

:NOTE:
=noweb= is a feature of =org-tangle= that does the replacement for values inside of the backets, referenced by name. Each reference has a =:cache no= so that the expression isn't evaluated - and thus substituted right in.
:END:

With that out of the way, we can get to our modes.

** Org Mode

This section is /heavily/ influenced by [[https://sophiebos.io/posts/beautifying-emacs-org-mode/][Beautifying Emacs Org Mode]] post. It adds some extra font goodness when using the GUI.

*** The setup

This is the basic structure that we will follow to fill out the =org-mode= settings.

#+begin_src emacs-lisp :noweb yes
  (use-package org
    :custom
    <<text-tweaks>>
    :hook
    <<font-hooks>>
    <<ui-hooks>>
    :config
    (pope-set-document-faces))
#+end_src

*** Fonts

We can set custom font sizes for each org heading level and document title.

#+name: org-headings
#+begin_src emacs-lisp :cache no :tangle no
  (dolist (face '((org-level-1 . 1.35)
                  (org-level-2 . 1.3)
                  (org-level-3 . 1.2)
                  (org-level-4 . 1.1)
                  (org-level-5 . 1.1)
                  (org-level-6 . 1.1)
                  (org-level-7 . 1.1)
                  (org-level-8 . 1.1)))
    (set-face-attribute (car face) nil :weight 'bold :height (cdr face)))
  (set-face-attribute 'org-document-title nil :weight 'bold :height 1.8)
#+end_src

Next up, let's make code blocks fixed pitched

#+name: org-fixed-pitch-faces
#+begin_src emacs-lisp :cache no :tangle no
  (set-face-attribute 'org-block nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-code nil :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-special-keyword nil
                      :inherit '(font-lock-comment-face fixed-pitch))
  (set-face-attribute 'org-meta-line nil
                      :inherit '(font-lock-comment-face fixed-pitch))
  (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)
#+end_src

If =org-indent= mode is used, we need to inherit from fixed-pitch as to not have funky alignment issues with mixed font widths.

#+begin_src emacs-lisp
  (use-package org-indent
    :after org
    :config
    (set-face-attribute 'org-indent nil :inherit '(org-hide fixed-pitch)))
#+end_src

Lastly, make sure these fonts get set when org-mode starts

#+name: font-hooks
#+begin_src emacs-lisp :cache no :tangle no
  (org-mode . variable-pitch-mode)
#+end_src

*** Text Tweaks

#+name: text-tweaks
#+begin_src emacs-lisp :cache no :tangle no
  (org-hide-leading-stars t)
  (org-hide-emphasis-markers t)
  (org-pretty-entities t)
#+end_src

*** UI

=olivetti= will center the org document in the window. And =org-modern-mode= to apply some interesting styles to things. Now when =org-mode= is activated, we can enable those two libraries, but there are some modes that need to be disabled.

- =diff-hl-margin-mode=  :: funky in both visuals and in performance, though it does conflict some with org-modern-mode visuals right now.
- =indent-bars-mode= :: Disabling this doesn't really feel like it's working, but it does add a little bit of visual noise.

#+name: ui-hooks
#+begin_src emacs-lisp :cache no :tangle no
  (org-mode . (lambda ()
                (olivetti-mode t)
                (org-modern-mode t)
                (display-line-numbers-mode -1)
                (indent-bars-mode -1)
                (diff-hl-margin-mode -1)))
#+end_src

** Markdown

And then for the Markdown files, it's much the same thing, so details will be light since it's mainly the equivilent of above.

#+name: markdown-faces
#+begin_src emacs-lisp :cache no :tangle no
  (dolist (face '((markdown-header-face-1 . 1.35)
                  (markdown-header-face-2 . 1.3)
                  (markdown-header-face-3 . 1.2)
                  (markdown-header-face-4 . 1.1)
                  (markdown-header-face-5 . 1.1)
                  (markdown-header-face-6 . 1.1)))
    (set-face-attribute (car face) nil :weight 'bold :height (cdr face)))
  (set-face-attribute 'markdown-code-face nil :inherit 'fixed-pitch)
#+end_src

#+begin_src emacs-lisp
  (use-package markdown-mode
    :custom
    (markdown-enable-highlighting-syntax t)
    (markdown-fontify-code-blocks-natively t)
    (markdown-hide-markup t)
    :hook
    (markdown-mode . (lambda ()
                       (variable-pitch-mode t)
                       (olivetti-mode t)
                       (display-line-numbers-mode -1)
                       (indent-bars-mode -1)
                       (diff-hl-margin-mode -1)))
    :config
    (pope-set-document-faces))
#+end_src

* Email

Emacs can do all the things - like read mail. So, why not? I have =mu= configured through my Nix email configs. So I will have =mu4e= re-use those configs. It should be noted that =mu index= needs to be run before any of that email gets processed my =mu4e=.

#+begin_src emacs-lisp
  (use-package mu4e
    :commands (mu4e)
    :custom
    (mu4e-drafts-folder "/shifteleven-admin/[Gmail]/Drafts")
    (mu4e-sent-folder "/shifteleven-admin/[Gmail]/Sent Mail")
    (mu4e-trash-folder "/shifteleven-admin/[Gmail]/Trash")

    (mu4e-sent-messages-behavior 'delete)

    (mu4e-get-mail-command "mbsync -ax"))
#+end_src
